---
phase: 04-frame-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - include/cels-ncurses/tui_frame.h
  - src/frame/tui_frame.c
  - include/cels-ncurses/tui_layer.h
  - src/layer/tui_layer.c
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "tui_frame_begin() clears only dirty layers and resets their style to default"
    - "tui_frame_end() composites all visible layers via update_panels() + doupdate()"
    - "tui_frame_invalidate_all() marks every layer dirty for forced full redraw"
    - "Obtaining a DrawContext from a layer auto-marks that layer dirty"
    - "Drawing outside a frame (before begin or after end) triggers assert in debug builds"
    - "Frame timing measures real elapsed time via clock_gettime(CLOCK_MONOTONIC)"
  artifacts:
    - path: "include/cels-ncurses/tui_frame.h"
      provides: "TUI_FrameState struct, frame pipeline API declarations"
      contains: "TUI_FrameState"
    - path: "src/frame/tui_frame.c"
      provides: "Frame pipeline implementation with dirty tracking"
      exports: ["tui_frame_begin", "tui_frame_end", "tui_frame_invalidate_all", "tui_frame_init", "tui_frame_register_systems", "tui_frame_get_background"]
    - path: "include/cels-ncurses/tui_layer.h"
      provides: "TUI_Layer struct with dirty flag"
      contains: "bool dirty"
    - path: "CMakeLists.txt"
      provides: "tui_frame.c added to INTERFACE sources"
      contains: "src/frame/tui_frame.c"
  key_links:
    - from: "src/frame/tui_frame.c"
      to: "g_layers"
      via: "extern from tui_layer.h"
      pattern: "g_layers\\[i\\]\\.dirty"
    - from: "src/layer/tui_layer.c"
      to: "tui_layer_get_draw_context"
      via: "sets dirty flag before returning context"
      pattern: "layer->dirty = true"
    - from: "src/frame/tui_frame.c"
      to: "update_panels.*doupdate"
      via: "tui_frame_end composites panels"
      pattern: "update_panels.*doupdate"
---

<objective>
Create the frame pipeline core: tui_frame.h/tui_frame.c with begin/end frame lifecycle, dirty tracking per layer, frame timing, and a default background layer. Add the dirty flag to TUI_Layer and auto-set it when a DrawContext is obtained.

Purpose: Provides the retained-mode frame lifecycle that orchestrates layer compositing with a single doupdate() per frame, replacing ad-hoc refresh patterns.
Output: New tui_frame.h header, new src/frame/tui_frame.c implementation, modified TUI_Layer struct with dirty flag, updated tui_layer_get_draw_context, updated CMakeLists.txt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frame-pipeline/04-CONTEXT.md
@.planning/phases/04-frame-pipeline/04-RESEARCH.md
@include/cels-ncurses/tui_layer.h
@src/layer/tui_layer.c
@include/cels-ncurses/tui_draw_context.h
@include/cels-ncurses/tui_scissor.h
@src/input/tui_input.c
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tui_frame.h header and add dirty flag to TUI_Layer</name>
  <files>
    include/cels-ncurses/tui_frame.h
    include/cels-ncurses/tui_layer.h
    src/layer/tui_layer.c
  </files>
  <action>
1. Create `include/cels-ncurses/tui_frame.h` with:
   - `TUI_FrameState` struct: `uint64_t frame_count`, `float delta_time`, `float fps`, `bool in_frame`
   - `extern TUI_FrameState g_frame_state;` (extern linkage, same INTERFACE pattern as g_layers)
   - Function declarations:
     - `void tui_frame_init(void)` -- creates default background layer, initializes state
     - `void tui_frame_begin(void)` -- clears dirty layers, resets style, updates timing
     - `void tui_frame_end(void)` -- composites via update_panels() + doupdate()
     - `void tui_frame_invalidate_all(void)` -- marks all layers dirty
     - `void tui_frame_register_systems(void)` -- registers ECS systems at PreStore/PostFrame
     - `TUI_Layer* tui_frame_get_background(void)` -- returns pointer to background layer
   - Include guards, includes: `<stdbool.h>`, `<stdint.h>`, `"cels-ncurses/tui_layer.h"`

2. Modify `include/cels-ncurses/tui_layer.h`:
   - Add `bool dirty;` field to `TUI_Layer` struct, after the `visible` field
   - Comment: `/* Auto-set by tui_layer_get_draw_context; cleared by tui_frame_begin */`

3. Modify `src/layer/tui_layer.c`:
   - In `tui_layer_create()`: initialize `layer->dirty = false;` after `layer->visible = true;`
   - In `tui_layer_get_draw_context()`: add `layer->dirty = true;` as the FIRST line before the return statement. This auto-marks the layer dirty whenever anything obtains a draw context for it.
  </action>
  <verify>
Build: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
Confirm no compilation errors. Check that tui_frame.h can be included and TUI_FrameState is defined.
  </verify>
  <done>
tui_frame.h exists with TUI_FrameState and all 6 function declarations. TUI_Layer has a bool dirty field. tui_layer_get_draw_context sets dirty=true. Build succeeds with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement tui_frame.c with frame lifecycle, dirty tracking, timing, and background layer</name>
  <files>
    src/frame/tui_frame.c
    CMakeLists.txt
  </files>
  <action>
1. Create directory `src/frame/` if it does not exist.

2. Create `src/frame/tui_frame.c` with:

   **Includes:** `<cels-ncurses/tui_frame.h>`, `<cels-ncurses/tui_layer.h>`, `<ncurses.h>`, `<panel.h>`, `<time.h>`, `<assert.h>`, `<cels/cels.h>`, `<flecs.h>`

   **Global state:**
   - `TUI_FrameState g_frame_state = {0};` (extern definition)
   - `static TUI_Layer* g_background_layer = NULL;`
   - `static struct timespec g_frame_start = {0};`
   - `static struct timespec g_prev_frame_start = {0};`

   **Helper:**
   - `static float timespec_diff_sec(struct timespec end, struct timespec start)` -- returns float seconds difference: `(float)(end.tv_sec - start.tv_sec) + (float)(end.tv_nsec - start.tv_nsec) / 1e9f`

   **tui_frame_init:**
   - Create background layer: `g_background_layer = tui_layer_create("background", 0, 0, COLS, LINES);`
   - If created, call `tui_layer_lower(g_background_layer);` to ensure z=0 (bottom)
   - Zero-initialize g_frame_state

   **tui_frame_begin:**
   - `assert(!g_frame_state.in_frame && "Nested tui_frame_begin() calls");`
   - Frame timing: save prev_frame_start, call `clock_gettime(CLOCK_MONOTONIC, &g_frame_start)`, compute delta_time and fps from difference (guard: only if prev.tv_sec != 0, and delta > 0 for fps). Increment frame_count.
   - Dirty layer clearing: iterate `g_layers[0..g_layer_count)`, for each where `dirty && visible`: call `werase(g_layers[i].win)` then `wattr_set(g_layers[i].win, A_NORMAL, 0, NULL)` then set `dirty = false`. Use `werase` NOT `wclear` (wclear causes flicker via clearok).
   - Set `g_frame_state.in_frame = true;`

   **tui_frame_end:**
   - `assert(g_frame_state.in_frame && "tui_frame_end() without tui_frame_begin()");`
   - Set `g_frame_state.in_frame = false;`
   - Call `update_panels();` then `doupdate();`

   **tui_frame_invalidate_all:**
   - Iterate `g_layers[0..g_layer_count)`, set each `dirty = true`

   **tui_frame_get_background:**
   - Return `g_background_layer;`

   **ECS system registration (tui_frame_register_systems):**
   - Follow the EXACT pattern from tui_input.c lines 149-161.
   - Static callback: `tui_frame_begin_callback(ecs_iter_t* it)` -- casts (void)it, calls tui_frame_begin()
   - Static callback: `tui_frame_end_callback(ecs_iter_t* it)` -- casts (void)it, calls tui_frame_end()
   - Get world: `ecs_world_t* world = cels_get_world(cels_get_context());`
   - Register frame_begin at EcsPreStore:
     ```
     ecs_system_desc_t sys_desc = {0};
     ecs_entity_desc_t entity_desc = {0};
     entity_desc.name = "TUI_FrameBeginSystem";
     ecs_id_t phase_ids[3] = { ecs_pair(EcsDependsOn, EcsPreStore), EcsPreStore, 0 };
     entity_desc.add = phase_ids;
     sys_desc.entity = ecs_entity_init(world, &entity_desc);
     sys_desc.callback = tui_frame_begin_callback;
     ecs_system_init(world, &sys_desc);
     ```
   - Register frame_end at EcsPostFrame with same pattern, name "TUI_FrameEndSystem"

3. Update `CMakeLists.txt`:
   - Add `${CMAKE_CURRENT_SOURCE_DIR}/src/frame/tui_frame.c` to the `target_sources(cels-ncurses INTERFACE ...)` list, after the tui_layer.c line.

  </action>
  <verify>
Build: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
Confirm clean compilation with no warnings or errors. Verify tui_frame.c is being compiled by checking the build output includes it.
  </verify>
  <done>
src/frame/tui_frame.c exists with all 6 functions implemented. CMakeLists.txt includes tui_frame.c. Build succeeds cleanly. Frame pipeline is ready to be integrated with the existing frame loop (Plan 04-02).
  </done>
</task>

</tasks>

<verification>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build` compiles with zero errors and zero warnings
2. `grep -n "dirty" include/cels-ncurses/tui_layer.h` shows the dirty field in TUI_Layer
3. `grep -n "dirty" src/layer/tui_layer.c` shows dirty=true in get_draw_context and dirty=false in create
4. `grep -n "tui_frame" include/cels-ncurses/tui_frame.h` shows all 6 function declarations
5. `grep -n "update_panels" src/frame/tui_frame.c` shows compositing in frame_end
6. `grep -n "werase" src/frame/tui_frame.c` shows dirty-only clearing in frame_begin
7. `grep -n "tui_frame.c" CMakeLists.txt` shows source added to INTERFACE target
</verification>

<success_criteria>
- TUI_FrameState struct defined with frame_count, delta_time, fps, in_frame
- g_frame_state has extern linkage (declared in .h, defined in .c)
- tui_frame_begin clears ONLY dirty+visible layers via werase (not wclear)
- tui_frame_begin resets style via wattr_set(win, A_NORMAL, 0, NULL) on dirty layers
- tui_frame_begin updates timing via clock_gettime(CLOCK_MONOTONIC)
- tui_frame_end calls update_panels() then doupdate()
- tui_frame_invalidate_all marks all layers dirty
- tui_frame_init creates a "background" layer at z=0
- tui_layer_get_draw_context sets layer->dirty = true
- ECS systems registered at EcsPreStore (begin) and EcsPostFrame (end)
- Build compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frame-pipeline/04-01-SUMMARY.md`
</output>
