---
phase: 04-frame-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/tui_engine.c
  - src/window/tui_window.c
  - src/renderer/tui_renderer.c
  - src/input/tui_input.c
  - include/cels-ncurses/tui_engine.h
autonomous: true

must_haves:
  truths:
    - "Frame loop no longer calls update_panels() or doupdate() directly -- frame_end handles it"
    - "Renderer draws into the background layer via stdscr-to-panel bridge (overwrite), not wnoutrefresh(stdscr)"
    - "doupdate() is called exactly once per frame (inside tui_frame_end only)"
    - "TUI_WindowState.width/height use COLS/LINES instead of hardcoded 600/800"
    - "KEY_RESIZE handler calls tui_frame_invalidate_all() to force full redraw"
    - "Frame pipeline systems are registered during engine module initialization"
  artifacts:
    - path: "src/window/tui_window.c"
      provides: "Simplified frame loop without update_panels/doupdate"
      contains: "Engine_Progress"
    - path: "src/renderer/tui_renderer.c"
      provides: "Renderer using background layer via overwrite bridge"
      contains: "tui_frame_get_background"
    - path: "src/tui_engine.c"
      provides: "Frame pipeline init and system registration"
      contains: "tui_frame_init"
    - path: "src/input/tui_input.c"
      provides: "KEY_RESIZE handler with frame invalidation"
      contains: "tui_frame_invalidate_all"
  key_links:
    - from: "src/tui_engine.c"
      to: "tui_frame_init"
      via: "called during module initialization"
      pattern: "tui_frame_init"
    - from: "src/tui_engine.c"
      to: "tui_frame_register_systems"
      via: "registers ECS systems for begin/end"
      pattern: "tui_frame_register_systems"
    - from: "src/renderer/tui_renderer.c"
      to: "tui_frame_get_background"
      via: "gets background layer for drawing"
      pattern: "tui_frame_get_background"
    - from: "src/input/tui_input.c"
      to: "tui_frame_invalidate_all"
      via: "forces full redraw on terminal resize"
      pattern: "tui_frame_invalidate_all"
---

<objective>
Integrate the frame pipeline with the existing frame loop, ECS engine, and renderer. Remove duplicate update_panels/doupdate from the window frame loop, register frame systems in the engine module, migrate the renderer from stdscr to the background layer, add frame invalidation on resize, and fix hardcoded window dimensions.

Purpose: Completes the frame pipeline by wiring it into the existing application lifecycle, eliminating direct stdscr refresh and ensuring exactly one doupdate() per frame.
Output: Modified tui_window.c, tui_renderer.c, tui_engine.c, tui_input.c, tui_engine.h.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frame-pipeline/04-CONTEXT.md
@.planning/phases/04-frame-pipeline/04-RESEARCH.md
@.planning/phases/04-frame-pipeline/04-01-SUMMARY.md
@src/window/tui_window.c
@src/renderer/tui_renderer.c
@src/tui_engine.c
@src/input/tui_input.c
@include/cels-ncurses/tui_engine.h
@include/cels-ncurses/tui_frame.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire frame pipeline into engine module and simplify frame loop</name>
  <files>
    src/tui_engine.c
    src/window/tui_window.c
    include/cels-ncurses/tui_engine.h
    src/input/tui_input.c
  </files>
  <action>
1. Modify `include/cels-ncurses/tui_engine.h`:
   - Add `#include <cels-ncurses/tui_frame.h>` after the existing tui_renderer.h include. This makes the frame API available to consumers through the engine header.

2. Modify `src/tui_engine.c`:
   - Add `#include "cels-ncurses/tui_frame.h"` at the top.
   - Inside `_CEL_DefineModule(TUI_Engine)`, AFTER `tui_renderer_init();` and BEFORE the root function call:
     - Call `tui_frame_init();` to create the background layer
     - Call `tui_frame_register_systems();` to register ECS systems at PreStore/PostFrame

3. Modify `src/window/tui_window.c`:
   - In `tui_window_frame_loop()`:
     - Fix hardcoded dimensions: Change `TUI_WindowState.width = 600;` to `TUI_WindowState.width = g_tui_config.width > 0 ? g_tui_config.width : COLS;`
     - Fix hardcoded dimensions: Change `TUI_WindowState.height = 800;` to `TUI_WindowState.height = g_tui_config.height > 0 ? g_tui_config.height : LINES;`
     - Remove `#include <panel.h>` (no longer used in this file after removing panel calls)
     - Remove `update_panels();` and `doupdate();` from the while loop (lines 133-134). Frame_end ECS system handles compositing.
     - The while loop becomes: `while (g_running) { Engine_Progress(delta); usleep((unsigned int)(delta * 1000000)); }`

4. Modify `src/input/tui_input.c`:
   - Add `#include "cels-ncurses/tui_frame.h"` at the top.
   - In the KEY_RESIZE case, add `tui_frame_invalidate_all();` AFTER `tui_layer_resize_all(COLS, LINES);` and BEFORE `TUI_WindowState.width = COLS;`. This forces all layers dirty after resize since content is stale at new dimensions.
  </action>
  <verify>
Build: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
Confirm clean compilation. Verify:
- `grep -n "update_panels\|doupdate" src/window/tui_window.c` returns no matches
- `grep -n "tui_frame_init\|tui_frame_register" src/tui_engine.c` shows both calls
- `grep -n "tui_frame_invalidate_all" src/input/tui_input.c` shows call in KEY_RESIZE handler
- `grep -n "600\|800" src/window/tui_window.c` returns no matches
  </verify>
  <done>
Frame loop simplified to Engine_Progress+usleep. Frame pipeline registered in engine module. KEY_RESIZE invalidates all layers. Window dimensions use COLS/LINES. Build compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate renderer from stdscr to background layer via overwrite bridge</name>
  <files>
    src/renderer/tui_renderer.c
  </files>
  <action>
The widget functions in tui_components.h (tui_render_canvas, tui_render_button, etc.) use mvprintw which writes to stdscr. Full migration of these widgets to DrawContext is Phase 5 scope. For Phase 4, use an `overwrite()` bridge: widgets draw to stdscr as before, then stdscr content is copied into the background layer's panel window. Frame_end composites the panel via update_panels+doupdate.

1. Add `#include "cels-ncurses/tui_frame.h"` at the top of tui_renderer.c.

2. In `tui_prov_render_screen()`, after the `if (!changed) return;` check and the state update lines (`last_screen = ...` etc.), make these changes:

3. Get the background layer and mark it dirty:
   ```c
   TUI_Layer* bg = tui_frame_get_background();
   if (!bg) return;
   TUI_DrawContext draw_ctx = tui_layer_get_draw_context(bg);
   (void)draw_ctx;
   ```

4. Replace `erase();` with `werase(stdscr);` -- still need to clear stdscr since widget functions write there via mvprintw. Using werase (explicit target) instead of erase (implicit stdscr).

5. Keep all widget rendering calls unchanged (tui_render_reset_row, tui_render_canvas, tui_render_button, tui_render_slider_cycle, tui_render_slider_toggle, tui_render_hint, tui_render_info_box). They still write to stdscr.

6. After the last widget call (`tui_render_info_box(...)`) and REPLACING the `wnoutrefresh(stdscr);` line, add:
   ```c
   overwrite(stdscr, bg->win);
   ```
   This copies all stdscr content into the background layer's panel window. The `overwrite()` ncurses function copies the overlapping area from source to destination, handling matching dimensions correctly since both are COLS x LINES.

7. Remove the `wnoutrefresh(stdscr);` line entirely. Frame_end's update_panels() + doupdate() handles the refresh of all panel windows.

The result: widgets write to stdscr -> overwrite copies to background layer window -> frame_end composites via panels. Phase 5 removes the stdscr middleman by rewriting widgets to use tui_draw_text(&ctx, ...) directly.
  </action>
  <verify>
Build: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | tail -20`
Confirm clean compilation. Verify:
- `grep -n "wnoutrefresh(stdscr)" src/renderer/tui_renderer.c` returns no matches
- `grep -n "tui_frame_get_background" src/renderer/tui_renderer.c` shows background layer usage
- `grep -n "overwrite" src/renderer/tui_renderer.c` shows stdscr-to-background copy
Run the app: `cd /home/cachy/workspaces/libs/cels && ./build/app` -- verify the UI renders without visual corruption, ghost characters, or flicker. Press Q to quit cleanly.
  </verify>
  <done>
Renderer no longer calls wnoutrefresh(stdscr). Widget rendering goes through stdscr bridge (overwrite to background layer). erase() replaced with werase(stdscr). Frame pipeline composites via update_panels+doupdate in frame_end only. Build compiles and app renders correctly.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build` compiles with zero errors
2. `grep -rn "update_panels\|doupdate" src/window/tui_window.c` returns nothing (removed from frame loop)
3. `grep -rn "update_panels" src/frame/tui_frame.c` shows call in tui_frame_end only
4. `grep -rn "doupdate" src/frame/tui_frame.c` shows call in tui_frame_end only
5. `grep -rn "wnoutrefresh(stdscr)" src/renderer/tui_renderer.c` returns nothing
6. `grep -rn "tui_frame_init\|tui_frame_register" src/tui_engine.c` shows both wiring calls
7. `grep -rn "tui_frame_invalidate_all" src/input/tui_input.c` shows resize handler integration
8. `grep -rn "600\|800" src/window/tui_window.c` returns nothing (hardcoded values fixed)
9. Run the app and verify: UI renders, Q quits, no visual corruption
</verification>

<success_criteria>
- update_panels() + doupdate() removed from tui_window_frame_loop
- tui_frame_init() and tui_frame_register_systems() called in tui_engine.c module init
- tui_engine.h includes tui_frame.h for consumer access
- KEY_RESIZE handler calls tui_frame_invalidate_all() after resize_all
- Renderer uses background layer (gets draw context, uses overwrite bridge)
- Renderer no longer calls wnoutrefresh(stdscr)
- TUI_WindowState uses COLS/LINES (not hardcoded 600/800)
- Application builds and renders correctly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frame-pipeline/04-02-SUMMARY.md`
</output>
