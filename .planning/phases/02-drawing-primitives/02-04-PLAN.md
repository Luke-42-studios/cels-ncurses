---
phase: 02-drawing-primitives
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - include/cels-ncurses/tui_scissor.h
  - src/graphics/tui_scissor.c
  - CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Developer can push a scissor rectangle that restricts all subsequent drawing to that region"
    - "Developer can pop a scissor rectangle to restore the previous clipping region"
    - "Nested scissor pushes correctly intersect -- inner clip is intersection of parent and child"
    - "Developer can reset the scissor stack to restore full drawable area for a new frame"
  artifacts:
    - path: "include/cels-ncurses/tui_scissor.h"
      provides: "tui_push_scissor, tui_pop_scissor, tui_scissor_reset declarations, TUI_SCISSOR_STACK_MAX define"
      contains: "extern void tui_push_scissor"
    - path: "src/graphics/tui_scissor.c"
      provides: "Scissor stack implementation with static array and stack pointer"
      contains: "static TUI_CellRect g_scissor_stack"
  key_links:
    - from: "src/graphics/tui_scissor.c"
      to: "tui_cell_rect_intersect"
      via: "nested clip intersection on push"
      pattern: "tui_cell_rect_intersect"
    - from: "src/graphics/tui_scissor.c"
      to: "TUI_DrawContext.clip"
      via: "updates ctx->clip on push/pop/reset"
      pattern: "ctx->clip"
    - from: "CMakeLists.txt"
      to: "src/graphics/tui_scissor.c"
      via: "INTERFACE target_sources"
      pattern: "tui_scissor\\.c"
---

<objective>
Implement the scissor/clip region stack that enables nested clipping for scroll containers and partial UI visibility.

Purpose: The scissor stack is the mechanism that makes all drawing primitives clip-aware. Push narrows the clip region (via intersection), pop restores the previous region. This enables Clay scroll containers and nested UI elements to restrict drawing to their visible area. The stack is a separate module (tui_scissor.h/c) with no dependency on tui_draw.h, so it can be built in parallel with plan 02-01.

Output: tui_scissor.h (declarations), tui_scissor.c (implementation), updated CMakeLists.txt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-drawing-primitives/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@include/cels-ncurses/tui_types.h
@include/cels-ncurses/tui_draw_context.h
@CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tui_scissor.h with scissor stack declarations</name>
  <files>include/cels-ncurses/tui_scissor.h</files>
  <action>
  Create the header file following project conventions (file-level doc comment, section separators, include guard CELS_NCURSES_TUI_SCISSOR_H, /* */ comments only, 4-space indent).

  File-level doc comment should explain:
  - Purpose: Manages a stack of clip rectangles for nested clipping regions
  - How it works: push intersects new rect with current top, pop restores previous. TUI_DrawContext.clip is updated on every push/pop/reset
  - Stack depth: TUI_SCISSOR_STACK_MAX (16 levels, sufficient for practical UI hierarchies)
  - Frame lifecycle: call tui_scissor_reset at frame start to clear stale state

  Usage example:
  ```
  tui_scissor_reset(&ctx);
  tui_push_scissor(&ctx, outer_region);
  /* draw calls clipped to outer_region */
  tui_push_scissor(&ctx, inner_region);
  /* draw calls clipped to intersection of outer and inner */
  tui_pop_scissor(&ctx);
  /* back to outer_region clipping */
  tui_pop_scissor(&ctx);
  /* back to full drawable area */
  ```

  Include:
  - "cels-ncurses/tui_draw_context.h" (for TUI_DrawContext)
  - "cels-ncurses/tui_types.h" (for TUI_CellRect)

  Define:
  - `#define TUI_SCISSOR_STACK_MAX 16`

  Declare (extern):
  - `extern void tui_scissor_reset(TUI_DrawContext* ctx);`
  - `extern void tui_push_scissor(TUI_DrawContext* ctx, TUI_CellRect rect);`
  - `extern void tui_pop_scissor(TUI_DrawContext* ctx);`
  </action>
  <verify>
  File exists at include/cels-ncurses/tui_scissor.h. Include guard is CELS_NCURSES_TUI_SCISSOR_H. Three extern function declarations present. TUI_SCISSOR_STACK_MAX defined as 16.
  </verify>
  <done>
  tui_scissor.h exists with TUI_SCISSOR_STACK_MAX define and extern declarations for tui_scissor_reset, tui_push_scissor, tui_pop_scissor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement scissor stack in tui_scissor.c and update CMakeLists.txt</name>
  <files>src/graphics/tui_scissor.c, CMakeLists.txt</files>
  <action>
  Create src/graphics/tui_scissor.c following conventions (POSIX feature test macros, file-level doc comment, own header first).

  Include:
  - `#define _POSIX_C_SOURCE 199309L`
  - `#define _DEFAULT_SOURCE`
  - `#include "cels-ncurses/tui_scissor.h"` (brings in tui_draw_context.h, tui_types.h)

  NOTE comment: This file compiles in the CONSUMER's context (INTERFACE library). Static variables are per-consumer translation unit.

  **Static state:**
  ```c
  static TUI_CellRect g_scissor_stack[TUI_SCISSOR_STACK_MAX];
  static int g_scissor_sp = 0;
  ```

  **tui_scissor_reset implementation:**
  - Set `g_scissor_stack[0]` to `(TUI_CellRect){ ctx->x, ctx->y, ctx->width, ctx->height }` (full drawable area from the draw context)
  - Set `g_scissor_sp = 0`
  - Set `ctx->clip = g_scissor_stack[0]`

  **tui_push_scissor implementation:**
  - Guard: if `g_scissor_sp >= TUI_SCISSOR_STACK_MAX - 1`, return immediately (stack full, silently ignore -- no assert, matching project error handling convention)
  - Compute `clipped = tui_cell_rect_intersect(rect, g_scissor_stack[g_scissor_sp])` -- intersect new rect with current top
  - Increment `g_scissor_sp`
  - Store `g_scissor_stack[g_scissor_sp] = clipped`
  - Update `ctx->clip = clipped`

  **tui_pop_scissor implementation:**
  - Guard: if `g_scissor_sp > 0`, decrement `g_scissor_sp`
  - Update `ctx->clip = g_scissor_stack[g_scissor_sp]`
  - If `g_scissor_sp` is already 0, do nothing (already at base -- silently ignore)

  **CMakeLists.txt update:**
  Add `${CMAKE_CURRENT_SOURCE_DIR}/src/graphics/tui_scissor.c` to the target_sources list, after the existing entries. If tui_draw.c was already added (by plan 02-01 running in parallel), add after it. If not, add after tui_color.c.

  IMPORTANT: Since plan 02-01 may also modify CMakeLists.txt in the same wave, check the current file state before editing. If tui_draw.c is already listed, add tui_scissor.c after it. If not, add after tui_color.c. The result should include both when both plans complete.
  </action>
  <verify>
  1. Build the project: verify no compilation errors or warnings.
  2. Grep for anti-patterns: `grep -n 'wrefresh\|wnoutrefresh\|doupdate' src/graphics/tui_scissor.c` should return no matches.
  3. Grep for correct state management: `grep -n 'g_scissor_stack\|g_scissor_sp' src/graphics/tui_scissor.c` shows static array and stack pointer.
  4. Verify CMakeLists.txt contains tui_scissor.c: `grep 'tui_scissor.c' CMakeLists.txt`
  5. Verify intersection is used on push: `grep 'tui_cell_rect_intersect' src/graphics/tui_scissor.c` returns a match.
  </verify>
  <done>
  tui_scissor.c implements a 16-deep scissor stack with push (intersects with current top), pop (restores previous), and reset (restores full drawable area). ctx->clip is updated on every operation. Stack overflow and underflow are handled gracefully with early return. CMakeLists.txt includes tui_scissor.c in INTERFACE sources.
  </done>
</task>

</tasks>

<verification>
- `include/cels-ncurses/tui_scissor.h` exists with TUI_SCISSOR_STACK_MAX and 3 function declarations
- `src/graphics/tui_scissor.c` exists with static stack array, push/pop/reset implementations
- Push uses tui_cell_rect_intersect for nested clip intersection
- Pop restores previous clip from stack
- Reset initializes stack to full drawable area from ctx dimensions
- Stack overflow (push beyond 15) is handled with silent early return
- Stack underflow (pop at 0) is handled with no-op
- ctx->clip is updated on every push, pop, and reset
- No wrefresh/wnoutrefresh/doupdate calls
- CMakeLists.txt lists tui_scissor.c in target_sources
- Build succeeds
</verification>

<success_criteria>
Developer can push/pop scissor rectangles that correctly restrict drawing to the clipped region. Nested clips produce the intersection of parent and child. Reset restores full drawable area for frame start. Stack handles overflow and underflow gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/02-drawing-primitives/02-04-SUMMARY.md`
</output>
