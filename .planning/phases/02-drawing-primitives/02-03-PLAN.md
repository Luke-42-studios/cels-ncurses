---
phase: 02-drawing-primitives
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-05"]
files_modified:
  - src/graphics/tui_draw.c
autonomous: true

must_haves:
  truths:
    - "Developer can draw borders with per-side control (top, right, bottom, left independently)"
    - "Developer can draw borders with single, double, or rounded corner styles"
    - "Corner characters are placed only when both adjacent sides are enabled"
    - "When only one adjacent side is enabled at a corner position, that side's line character extends into the corner cell"
    - "All border drawing clips against TUI_DrawContext.clip"
  artifacts:
    - path: "src/graphics/tui_draw.c"
      provides: "tui_draw_border implementation with per-side control"
      contains: "tui_draw_border"
  key_links:
    - from: "tui_draw_border"
      to: "tui_border_chars_get"
      via: "gets correct characters for border style"
      pattern: "tui_border_chars_get"
    - from: "tui_draw_border"
      to: "TUI_SIDE_TOP"
      via: "bitmask check for per-side control"
      pattern: "TUI_SIDE_TOP"
    - from: "tui_draw_border"
      to: "tui_cell_rect_contains"
      via: "per-cell clip check for corners and line segments"
      pattern: "tui_cell_rect_contains"
---

<objective>
Implement per-side border drawing with corner logic for single, double, and rounded border styles.

Purpose: Borders are the most complex drawing primitive because they combine per-side control with corner character logic. A corner is drawn only when both adjacent sides are enabled; when only one side is present, the line extends into the corner cell. This matches Clay's per-side border width model where each side can be independently enabled/disabled.

Output: tui_draw_border function added to the existing tui_draw.c.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-drawing-primitives/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@include/cels-ncurses/tui_draw.h
@src/graphics/tui_draw.c
@.planning/phases/02-drawing-primitives/02-01-SUMMARY.md
@.planning/phases/02-drawing-primitives/02-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tui_draw_border with per-side control and corner logic</name>
  <files>src/graphics/tui_draw.c</files>
  <action>
  Add tui_draw_border to tui_draw.c in a new section after the line drawing section:

  ```c
  /* ============================================================================
   * Border Drawing (DRAW-05, DRAW-06, DRAW-07)
   * ============================================================================ */
  ```

  **tui_draw_border implementation:**
  - Parameters: `TUI_DrawContext* ctx, TUI_CellRect rect, uint8_t sides, TUI_BorderStyle border_style, TUI_Style style`
  - Early return if `rect.w < 2 || rect.h < 2` (need at least 2x2 for a border)
  - Early return if `sides == 0` (no sides to draw)
  - Get border characters: `TUI_BorderChars chars = tui_border_chars_get(border_style)`
  - Apply style: `tui_style_apply(ctx->win, style)`

  Compute the four corner positions:
  - `ul_x = rect.x`, `ul_y = rect.y` (upper-left)
  - `ur_x = rect.x + rect.w - 1`, `ur_y = rect.y` (upper-right)
  - `ll_x = rect.x`, `ll_y = rect.y + rect.h - 1` (lower-left)
  - `lr_x = rect.x + rect.w - 1`, `lr_y = rect.y + rect.h - 1` (lower-right)

  **Corner logic** (for each of the 4 corners, check both adjacent sides):

  Upper-left corner (ul_x, ul_y):
  - If both TUI_SIDE_TOP and TUI_SIDE_LEFT are set: draw corner char `chars.ul`
  - Else if only TUI_SIDE_TOP is set: draw `chars.hline` (extend top line into corner)
  - Else if only TUI_SIDE_LEFT is set: draw `chars.vline` (extend left line into corner)
  - Else: draw nothing
  - Before drawing, check `tui_cell_rect_contains(ctx->clip, ul_x, ul_y)`

  Upper-right corner (ur_x, ur_y):
  - Both TUI_SIDE_TOP and TUI_SIDE_RIGHT: draw `chars.ur`
  - Only TUI_SIDE_TOP: draw `chars.hline`
  - Only TUI_SIDE_RIGHT: draw `chars.vline`

  Lower-left corner (ll_x, ll_y):
  - Both TUI_SIDE_BOTTOM and TUI_SIDE_LEFT: draw `chars.ll`
  - Only TUI_SIDE_BOTTOM: draw `chars.hline`
  - Only TUI_SIDE_LEFT: draw `chars.vline`

  Lower-right corner (lr_x, lr_y):
  - Both TUI_SIDE_BOTTOM and TUI_SIDE_RIGHT: draw `chars.lr`
  - Only TUI_SIDE_BOTTOM: draw `chars.hline`
  - Only TUI_SIDE_RIGHT: draw `chars.vline`

  Use `mvwadd_wch(ctx->win, y, x, cchar)` for each corner/extension character, after the clip check.

  **Side lines** (draw the line segments between corners, excluding corner cells):

  Top side (if TUI_SIDE_TOP is set):
  - For col from `rect.x + 1` to `rect.x + rect.w - 2` (inclusive), if `tui_cell_rect_contains(ctx->clip, col, rect.y)`, draw `mvwadd_wch(ctx->win, rect.y, col, chars.hline)`

  Bottom side (if TUI_SIDE_BOTTOM is set):
  - For col from `rect.x + 1` to `rect.x + rect.w - 2`, if `tui_cell_rect_contains(ctx->clip, col, rect.y + rect.h - 1)`, draw `mvwadd_wch(ctx->win, rect.y + rect.h - 1, col, chars.hline)`

  Left side (if TUI_SIDE_LEFT is set):
  - For row from `rect.y + 1` to `rect.y + rect.h - 2`, if `tui_cell_rect_contains(ctx->clip, rect.x, row)`, draw `mvwadd_wch(ctx->win, row, rect.x, chars.vline)`

  Right side (if TUI_SIDE_RIGHT is set):
  - For row from `rect.y + 1` to `rect.y + rect.h - 2`, if `tui_cell_rect_contains(ctx->clip, rect.x + rect.w - 1, row)`, draw `mvwadd_wch(ctx->win, row, rect.x + rect.w - 1, chars.vline)`

  NOTE: Use per-cell loops with tui_cell_rect_contains for the line segments (not mvwhline_set/mvwvline_set) because the line segments here exclude the corner cells and need individual clip checks. This is different from the standalone tui_draw_hline/vline functions which draw full-length lines. Using mvwadd_wch per cell is correct here.

  No wrefresh/wnoutrefresh/doupdate calls.
  </action>
  <verify>
  1. Build the project: verify no compilation errors or warnings.
  2. `grep -n 'tui_draw_border' src/graphics/tui_draw.c` shows the function implementation.
  3. `grep -n 'TUI_SIDE_TOP\|TUI_SIDE_RIGHT\|TUI_SIDE_BOTTOM\|TUI_SIDE_LEFT' src/graphics/tui_draw.c` shows per-side bitmask checks.
  4. `grep -n 'tui_cell_rect_contains' src/graphics/tui_draw.c` shows per-cell clip checks.
  5. `grep -n 'wrefresh\|wnoutrefresh\|doupdate' src/graphics/tui_draw.c` returns no matches.
  6. Verify corner logic: search for all 4 corner character references (chars.ul, chars.ur, chars.ll, chars.lr).
  </verify>
  <done>
  tui_draw_border draws borders with independent per-side control using TUI_SIDE_* bitmask. Corner characters are placed only when both adjacent sides are enabled; otherwise the present side's line character extends into the corner cell. Supports single, double, and rounded border styles via tui_border_chars_get. All cells are clipped against ctx->clip before drawing.
  </done>
</task>

</tasks>

<verification>
- tui_draw_border exists in src/graphics/tui_draw.c
- Per-side control uses TUI_SIDE_* bitmask checks
- Corner logic: corner char when both adjacent sides set, line extension when one side set, nothing when neither
- All four corners handled (ul, ur, ll, lr)
- All four sides handled (top, bottom, left, right) with line segments excluding corner cells
- Clips every cell against ctx->clip using tui_cell_rect_contains
- Supports single, double, rounded via tui_border_chars_get
- No wrefresh/wnoutrefresh/doupdate calls
- Build succeeds
</verification>

<success_criteria>
Developer can draw borders with per-side control and correct corner handling for single, double, and rounded styles. Corner characters appear only when both adjacent sides are drawn. Line characters extend into corner positions when only one adjacent side is present.
</success_criteria>

<output>
After completion, create `.planning/phases/02-drawing-primitives/02-03-SUMMARY.md`
</output>
