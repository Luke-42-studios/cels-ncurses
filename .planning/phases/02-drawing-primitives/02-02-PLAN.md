---
phase: 02-drawing-primitives
plan: 02
type: execute
wave: 4
depends_on: ["02-01"]
files_modified:
  - src/graphics/tui_draw.c
autonomous: true

must_haves:
  truths:
    - "Developer can render text at a specific cell position with a given style"
    - "Developer can render bounded text that does not exceed a maximum column width"
    - "Text rendering correctly handles UTF-8 multibyte strings via wchar_t conversion"
    - "Wide characters (CJK) that straddle the clip boundary are skipped to prevent overflow"
    - "Text is clipped against TUI_DrawContext.clip horizontally and vertically"
  artifacts:
    - path: "src/graphics/tui_draw.c"
      provides: "tui_draw_text, tui_draw_text_bounded implementations"
      contains: "tui_draw_text"
  key_links:
    - from: "tui_draw_text"
      to: "mbstowcs"
      via: "UTF-8 to wchar_t conversion"
      pattern: "mbstowcs"
    - from: "tui_draw_text"
      to: "wcwidth"
      via: "column width measurement per wide character"
      pattern: "wcwidth"
    - from: "tui_draw_text"
      to: "mvwaddnwstr"
      via: "renders the visible wchar_t slice"
      pattern: "mvwaddnwstr"
    - from: "tui_draw_text_bounded"
      to: "tui_draw_text"
      via: "temporarily narrows clip then delegates to tui_draw_text"
      pattern: "tui_draw_text"
---

<objective>
Implement text rendering with UTF-8 support, column-accurate clipping, and bounded text for Clay text bounding.

Purpose: Text rendering is the most complex drawing primitive due to the mismatch between byte length, wchar_t count, and display column width. CJK characters occupy 2 columns but are 1 wchar_t element. The implementation converts UTF-8 to wchar_t, walks the array counting columns via wcwidth(), computes the visible slice, and renders with mvwaddnwstr(). Bounded text temporarily narrows the clip region and delegates to the same logic.

Output: tui_draw_text and tui_draw_text_bounded added to the existing tui_draw.c.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-drawing-primitives/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@include/cels-ncurses/tui_draw.h
@src/graphics/tui_draw.c
@.planning/phases/02-drawing-primitives/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tui_draw_text with column-accurate clipping</name>
  <files>src/graphics/tui_draw.c</files>
  <action>
  Add wchar.h and stdlib.h includes at the top of tui_draw.c (if not already present):
  - `#include <wchar.h>` (for wchar_t, wcwidth, mbstowcs)
  - `#include <stdlib.h>` (for mbstowcs, malloc, free)

  Add a new section after the existing sections in tui_draw.c:

  ```c
  /* ============================================================================
   * Text Drawing (DRAW-03, DRAW-04)
   * ============================================================================ */
  ```

  **tui_draw_text implementation:**
  - Parameters: `TUI_DrawContext* ctx, int x, int y, const char* text, TUI_Style style`
  - Early return if `text == NULL`
  - Clip vertically: if `y < ctx->clip.y || y >= ctx->clip.y + ctx->clip.h`, return (row not visible)

  UTF-8 to wchar_t conversion:
  - Use a stack-allocated buffer for typical strings: `wchar_t wbuf_stack[256];`
  - Declare `wchar_t* wbuf = wbuf_stack;`
  - Declare `int wlen;`
  - First, measure the string length: `size_t needed = mbstowcs(NULL, text, 0);`
  - If `needed == (size_t)-1`, return (invalid UTF-8)
  - If `needed >= 256`, allocate dynamically: `wbuf = malloc((needed + 1) * sizeof(wchar_t));` with a NULL check (return if malloc fails)
  - Convert: `wlen = (int)mbstowcs(wbuf, text, needed + 1);`
  - If `wlen <= 0`, free wbuf if heap-allocated and return

  Column-accurate horizontal clipping:
  - Compute clip boundaries:
    - `clip_left = ctx->clip.x`
    - `clip_right = ctx->clip.x + ctx->clip.w`
  - Walk the wchar_t array counting columns:
    ```c
    int col = x;           /* Current column position */
    int start_idx = -1;    /* First wchar_t index in visible range */
    int end_idx = wlen;    /* One past last wchar_t index in visible range */
    int draw_x = x;        /* Column where rendering actually starts */

    for (int i = 0; i < wlen; i++) {
        int cw = wcwidth(wbuf[i]);
        if (cw < 0) cw = 0;  /* Non-printable: treat as zero-width */

        if (start_idx == -1) {
            /* Haven't found the start of visible region yet */
            if (col + cw > clip_left) {
                /* This character starts or extends into visible region */
                if (col < clip_left) {
                    /* Wide char straddles left clip boundary -- skip it */
                    col += cw;
                    continue;
                }
                start_idx = i;
                draw_x = col;
            }
        }

        if (col >= clip_right) {
            end_idx = i;
            break;
        }

        /* Check if this character extends past the right clip boundary */
        if (col + cw > clip_right && start_idx != -1) {
            /* Wide char straddles right clip boundary -- exclude it */
            end_idx = i;
            break;
        }

        col += cw;
    }
    ```
  - If `start_idx == -1`, the text is fully clipped. Free wbuf if heap-allocated and return.
  - After the loop, if we didn't hit clip_right, `end_idx` remains `wlen` (all remaining chars are visible).

  Render:
  - `tui_style_apply(ctx->win, style);`
  - `mvwaddnwstr(ctx->win, y, draw_x, &wbuf[start_idx], end_idx - start_idx);`

  Cleanup:
  - If `wbuf != wbuf_stack`, call `free(wbuf);`
  - No wrefresh/wnoutrefresh/doupdate calls

  IMPORTANT: The `n` parameter of mvwaddnwstr counts wchar_t ELEMENTS, not display columns. The column counting done above ensures we pass the correct element range that fits within the visible column range.

  IMPORTANT: Wide characters (CJK, 2-column) that straddle the left or right clip boundary must be SKIPPED entirely. Drawing half a wide character would corrupt the display.
  </action>
  <verify>
  1. Build the project: verify no compilation errors or warnings.
  2. `grep -n 'tui_draw_text' src/graphics/tui_draw.c` shows the function implementation.
  3. `grep -n 'mbstowcs' src/graphics/tui_draw.c` shows UTF-8 conversion.
  4. `grep -n 'wcwidth' src/graphics/tui_draw.c` shows column width measurement.
  5. `grep -n 'mvwaddnwstr' src/graphics/tui_draw.c` shows the ncurses render call.
  6. `grep -n 'wrefresh\|wnoutrefresh\|doupdate' src/graphics/tui_draw.c` returns no matches.
  7. `grep -n 'wbuf_stack\|malloc\|free' src/graphics/tui_draw.c` shows the stack-buffer-with-fallback pattern.
  </verify>
  <done>
  tui_draw_text renders UTF-8 text at a given position with column-accurate clipping. Handles multibyte UTF-8 via mbstowcs, measures column widths via wcwidth, clips wide characters that straddle clip boundaries by skipping them entirely. Uses stack buffer for typical strings with malloc fallback for long strings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement tui_draw_text_bounded</name>
  <files>src/graphics/tui_draw.c</files>
  <action>
  Add tui_draw_text_bounded immediately after tui_draw_text in the same Text Drawing section:

  **tui_draw_text_bounded implementation:**
  - Parameters: `TUI_DrawContext* ctx, int x, int y, const char* text, int max_cols, TUI_Style style`
  - This function temporarily narrows the clip region to enforce the max column width, then delegates to tui_draw_text.
  - Implementation:
    ```c
    void tui_draw_text_bounded(TUI_DrawContext* ctx, int x, int y,
                                const char* text, int max_cols,
                                TUI_Style style) {
        if (max_cols <= 0) return;

        /* Create a bounding rect for the text area */
        TUI_CellRect text_bounds = { .x = x, .y = y, .w = max_cols, .h = 1 };

        /* Temporarily narrow the clip to the intersection of current clip and text bounds */
        TUI_CellRect saved_clip = ctx->clip;
        ctx->clip = tui_cell_rect_intersect(ctx->clip, text_bounds);

        /* Delegate to tui_draw_text which will clip against the narrowed region */
        tui_draw_text(ctx, x, y, text, style);

        /* Restore original clip */
        ctx->clip = saved_clip;
    }
    ```
  - This approach reuses all the clipping logic in tui_draw_text. The temporary clip ensures text cannot exceed max_cols from the starting x position, while still respecting the parent clip region.
  - No wrefresh/wnoutrefresh/doupdate calls.
  </action>
  <verify>
  1. Build the project: verify no compilation errors or warnings.
  2. `grep -n 'tui_draw_text_bounded' src/graphics/tui_draw.c` shows the function.
  3. `grep -n 'tui_cell_rect_intersect' src/graphics/tui_draw.c` shows clip intersection in bounded text.
  4. `grep -n 'saved_clip' src/graphics/tui_draw.c` shows clip save/restore pattern.
  5. `grep -n 'wrefresh\|wnoutrefresh\|doupdate' src/graphics/tui_draw.c` returns no matches.
  </verify>
  <done>
  tui_draw_text_bounded enforces a maximum column width by temporarily narrowing the clip region (intersection of current clip and text bounds), delegating to tui_draw_text, then restoring the original clip. Text that exceeds max_cols is clipped, not wrapped.
  </done>
</task>

</tasks>

<verification>
- tui_draw_text exists in src/graphics/tui_draw.c with full column-accurate clipping
- tui_draw_text_bounded exists and delegates to tui_draw_text with narrowed clip
- UTF-8 conversion via mbstowcs, column measurement via wcwidth, rendering via mvwaddnwstr
- Wide characters straddling clip boundaries are skipped entirely (not half-drawn)
- Stack buffer (256 wchar_t) with malloc fallback for long strings
- max_cols <= 0 handled with early return
- NULL text handled with early return
- No wrefresh/wnoutrefresh/doupdate calls
- Build succeeds
</verification>

<success_criteria>
Developer can render positioned text with style at any cell position. Text is clipped horizontally and vertically against the draw context's clip region. Bounded text does not exceed the specified maximum column width. UTF-8 multibyte strings are handled correctly, and CJK wide characters at clip boundaries do not overflow.
</success_criteria>

<output>
After completion, create `.planning/phases/02-drawing-primitives/02-02-SUMMARY.md`
</output>
