---
phase: 03-layer-system
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/input/tui_input.c
  - src/window/tui_window.c
  - include/cels-ncurses/tui_layer.h
  - src/layer/tui_layer.c
autonomous: true

must_haves:
  truths:
    - "Terminal resize (SIGWINCH) is detected via KEY_RESIZE from wgetch in input loop"
    - "On resize, all layer surfaces are resized via wresize + replace_panel"
    - "On resize, TUI_WindowState dimensions are updated to new COLS/LINES and observers notified"
    - "Frame loop uses update_panels() + doupdate() instead of bare doupdate()"
  artifacts:
    - path: "src/input/tui_input.c"
      provides: "KEY_RESIZE handler that resizes all layers and notifies observers"
      contains: "KEY_RESIZE"
    - path: "src/window/tui_window.c"
      provides: "Frame loop with update_panels() before doupdate()"
      contains: "update_panels"
    - path: "include/cels-ncurses/tui_layer.h"
      provides: "tui_layer_resize_all declaration"
      contains: "tui_layer_resize_all"
    - path: "src/layer/tui_layer.c"
      provides: "tui_layer_resize_all implementation"
      contains: "tui_layer_resize_all"
  key_links:
    - from: "src/input/tui_input.c"
      to: "src/layer/tui_layer.c"
      via: "KEY_RESIZE triggers tui_layer_resize_all"
      pattern: "KEY_RESIZE.*tui_layer_resize_all"
    - from: "src/input/tui_input.c"
      to: "TUI_WindowState"
      via: "resize updates dimensions and notifies"
      pattern: "TUI_WindowState\\.width.*COLS"
    - from: "src/window/tui_window.c"
      to: "update_panels"
      via: "panel compositing before doupdate"
      pattern: "update_panels\\(\\)"
---

<objective>
Add terminal resize handling (KEY_RESIZE detection, layer resize-all, observer notification) and migrate the frame loop to use update_panels() + doupdate().

Purpose: Complete Phase 3 by making the layer system respond correctly to terminal resizes and ensuring the frame loop uses panel compositing instead of bare doupdate(). After this plan, all Phase 3 requirements are satisfied.

Output: tui_input.c with KEY_RESIZE handler, tui_window.c frame loop using update_panels(), tui_layer.h/c with resize-all helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-layer-system/03-RESEARCH.md
@.planning/phases/03-layer-system/03-02-SUMMARY.md

@src/input/tui_input.c                  -- add KEY_RESIZE handler here
@src/window/tui_window.c                -- modify frame loop here
@include/cels-ncurses/tui_layer.h       -- add resize_all declaration
@src/layer/tui_layer.c                  -- add resize_all implementation
@include/cels-ncurses/tui_window.h      -- TUI_WindowState extern, WindowState enum
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tui_layer_resize_all helper and update frame loop</name>
  <files>include/cels-ncurses/tui_layer.h, src/layer/tui_layer.c, src/window/tui_window.c</files>
  <action>
  **tui_layer.h -- add declaration:**
  ```c
  /* Resize all layers to new terminal dimensions.
   * Called by input system on KEY_RESIZE. Each layer is resized to the
   * full new terminal size. Applications needing per-layer resize policies
   * should iterate g_layers directly. */
  extern void tui_layer_resize_all(int new_cols, int new_lines);
  ```

  **tui_layer.c -- add implementation:**
  `tui_layer_resize_all(int new_cols, int new_lines)`:
  - Loop over all layers (i = 0 to g_layer_count - 1):
    - Call `tui_layer_resize(&g_layers[i], new_cols, new_lines)` for each layer
  - This resizes every layer to the full terminal size. This is the simplest resize policy and correct for the common case (full-screen layers). Applications needing different behavior (fixed-size panels, proportional layouts) will iterate g_layers and call tui_layer_resize individually in their resize observer.

  **tui_window.c -- modify frame loop:**
  1. Add `#include <panel.h>` at the top of the file (after `#include <ncurses.h>`)
  2. In `tui_window_frame_loop`, change the frame loop body from:
     ```c
     while (g_running) {
         Engine_Progress(delta);
         doupdate();
         usleep((unsigned int)(delta * 1000000));
     }
     ```
     to:
     ```c
     while (g_running) {
         Engine_Progress(delta);
         update_panels();
         doupdate();
         usleep((unsigned int)(delta * 1000000));
     }
     ```
  - `update_panels()` replaces all individual wnoutrefresh calls. It handles panel overlap resolution and calls wnoutrefresh on each visible panel window in the correct order.
  - `doupdate()` then flushes to the physical screen (already exists).
  - Do NOT remove the existing `doupdate()` -- it stays, but now follows `update_panels()`.
  </action>
  <verify>
  Run: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | head -30`
  Build succeeds. Verify: `grep -n "update_panels" modules/cels-ncurses/src/window/tui_window.c` shows update_panels in frame loop.
  </verify>
  <done>
  Frame loop calls update_panels() before doupdate(). tui_layer_resize_all iterates all layers and calls tui_layer_resize on each. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add KEY_RESIZE handler to input system</name>
  <files>src/input/tui_input.c</files>
  <action>
  **Modify tui_input.c:**

  1. Add includes at the top:
     - `#include "cels-ncurses/tui_layer.h"` (for tui_layer_resize_all)

  2. In `tui_read_input_ncurses`, inside the `switch (ch)` block, add a `case KEY_RESIZE:` BEFORE the `default:` case. The handler must:

     a. Call `tui_layer_resize_all(COLS, LINES)` -- resize all layers to the new terminal dimensions. `COLS` and `LINES` are ncurses global variables that are already updated by ncurses internally when SIGWINCH fires and resizeterm() runs.

     b. Update TUI_WindowState:
        ```c
        TUI_WindowState.width = COLS;
        TUI_WindowState.height = LINES;
        TUI_WindowState.state = WINDOW_STATE_RESIZING;
        ```

     c. Notify observers: `cels_state_notify_change(TUI_WindowStateID);`

     d. IMPORTANT ordering: Resize ALL layers FIRST, THEN notify observers. If notification happens before resize, observer code may try to draw into layers with stale dimensions.

     e. After notification, do NOT set state back to READY here. The next frame's Engine_Progress will handle that naturally (or the application's resize observer can set it back to READY).

     f. `return;` after handling (do not set any input fields for resize events).

  The case should look like:
  ```c
  case KEY_RESIZE:
      tui_layer_resize_all(COLS, LINES);
      TUI_WindowState.width = COLS;
      TUI_WindowState.height = LINES;
      TUI_WindowState.state = WINDOW_STATE_RESIZING;
      cels_state_notify_change(TUI_WindowStateID);
      return;
  ```

  Place it after the `case 'q': case 'Q':` block and before the `default:` case.
  </action>
  <verify>
  Run: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | head -30`
  Build succeeds. Verify: `grep -n "KEY_RESIZE" modules/cels-ncurses/src/input/tui_input.c` shows the resize handler. Verify `grep -n "tui_layer_resize_all" modules/cels-ncurses/src/input/tui_input.c` shows it's called before WindowState update.
  </verify>
  <done>
  KEY_RESIZE handler resizes all layers via tui_layer_resize_all, updates TUI_WindowState dimensions to COLS/LINES, sets state to WINDOW_STATE_RESIZING, and notifies observers. Resize happens BEFORE notification (correct ordering). Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build` compiles without errors
2. `grep -n "update_panels" modules/cels-ncurses/src/window/tui_window.c` shows update_panels() before doupdate()
3. `grep -n "KEY_RESIZE" modules/cels-ncurses/src/input/tui_input.c` shows resize handler
4. `grep -n "tui_layer_resize_all" modules/cels-ncurses/src/input/tui_input.c` -- called before cels_state_notify_change
5. No calls to `wnoutrefresh(stdscr)` in tui_layer.c or tui_window.c frame loop (wnoutrefresh in tui_renderer.c is fine -- it will be migrated in Phase 5)
6. `grep -n "WINDOW_STATE_RESIZING" modules/cels-ncurses/src/input/tui_input.c` shows state transition on resize
</verification>

<success_criteria>
- KEY_RESIZE case in tui_input.c switch block calls tui_layer_resize_all(COLS, LINES)
- After resize_all, TUI_WindowState.width/height updated to COLS/LINES and state set to WINDOW_STATE_RESIZING
- cels_state_notify_change called AFTER all layers are resized (correct ordering)
- Frame loop in tui_window.c calls update_panels() immediately before doupdate()
- tui_layer_resize_all iterates g_layers and calls tui_layer_resize on each
- Full project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-layer-system/03-03-SUMMARY.md`
</output>
