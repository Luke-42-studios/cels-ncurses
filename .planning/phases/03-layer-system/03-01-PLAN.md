---
phase: 03-layer-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - CMakeLists.txt
  - include/cels-ncurses/tui_layer.h
  - src/layer/tui_layer.c
autonomous: true

must_haves:
  truths:
    - "Developer can create a named layer with position, dimensions and it is backed by a PANEL"
    - "Developer can destroy a layer, freeing both its WINDOW and PANEL resources"
    - "Panel library is linked and available (panelw)"
  artifacts:
    - path: "include/cels-ncurses/tui_layer.h"
      provides: "TUI_Layer struct, TUI_LAYER_MAX constant, extern globals, create/destroy API"
      contains: "typedef struct TUI_Layer"
    - path: "src/layer/tui_layer.c"
      provides: "Global layer array definition, create/destroy implementation"
      contains: "g_layers"
    - path: "CMakeLists.txt"
      provides: "Panel library linkage"
      contains: "PANEL_LIBRARY"
  key_links:
    - from: "src/layer/tui_layer.c"
      to: "new_panel"
      via: "ncurses panel API"
      pattern: "new_panel\\(layer->win\\)"
    - from: "src/layer/tui_layer.c"
      to: "del_panel.*delwin"
      via: "cleanup sequence"
      pattern: "del_panel.*delwin"
    - from: "include/cels-ncurses/tui_layer.h"
      to: "src/layer/tui_layer.c"
      via: "extern global definitions"
      pattern: "extern TUI_Layer g_layers"
---

<objective>
Create the layer type system with panel-backed create/destroy and link the panel library.

Purpose: Establish the TUI_Layer struct, global layer manager, and basic lifecycle (create/destroy) that all subsequent layer operations and the resize system build on. This is the foundation of Phase 3.

Output: tui_layer.h header with TUI_Layer struct and API declarations, tui_layer.c with global state and create/destroy implementation, CMakeLists.txt updated to find and link panelw.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-layer-system/03-RESEARCH.md

@include/cels-ncurses/tui_window.h     -- extern pattern reference (TUI_WindowState)
@src/window/tui_window.c               -- extern definition pattern reference
@include/cels-ncurses/tui_draw_context.h -- TUI_DrawContext struct (used by bridge in later plan)
@include/cels-ncurses/tui_types.h      -- TUI_CellRect (used in layer dimensions)
@CMakeLists.txt                         -- current build config to modify
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add panel library to CMake and create tui_layer.h</name>
  <files>CMakeLists.txt, include/cels-ncurses/tui_layer.h</files>
  <action>
  **CMakeLists.txt changes:**
  1. After the existing `find_package(Curses REQUIRED)` line, add:
     ```cmake
     find_library(PANEL_LIBRARY NAMES panelw panel)
     ```
  2. In the `target_link_libraries(cels-ncurses INTERFACE ...)` block, add `${PANEL_LIBRARY}` after `${CURSES_LIBRARIES}`.
  3. In the `draw_test` target's `target_link_libraries`, also add `${PANEL_LIBRARY}` after `${CURSES_LIBRARIES}`.

  **tui_layer.h creation:**
  Create `include/cels-ncurses/tui_layer.h` with:
  - Include guards `CELS_NCURSES_TUI_LAYER_H`
  - `#include <ncurses.h>` and `#include <panel.h>` and `#include <stdbool.h>`
  - `#define TUI_LAYER_MAX 32`
  - `TUI_Layer` struct with fields:
    - `char name[64]` -- human-readable identifier
    - `PANEL* panel` -- owned, del_panel on destroy
    - `WINDOW* win` -- owned, delwin on destroy
    - `int x, y` -- position (screen coordinates)
    - `int width, height` -- dimensions
    - `bool visible` -- visibility state
  - Extern declarations following the same pattern as tui_window.h:
    - `extern TUI_Layer g_layers[TUI_LAYER_MAX];`
    - `extern int g_layer_count;`
  - Function declarations:
    - `extern TUI_Layer* tui_layer_create(const char* name, int x, int y, int w, int h);`
    - `extern void tui_layer_destroy(TUI_Layer* layer);`

  Follow the exact doc-comment style from tui_draw_context.h and tui_color.h (block comments with section headers using `/* ==== ... ==== */`).
  </action>
  <verify>
  Run: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | head -30`
  The build should succeed (no undefined references, no missing headers). Specifically verify no `panel.h: No such file` or `undefined reference to new_panel` errors.
  </verify>
  <done>
  tui_layer.h exists with TUI_Layer struct and extern declarations. CMakeLists.txt finds and links panelw. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement tui_layer_create and tui_layer_destroy in tui_layer.c</name>
  <files>src/layer/tui_layer.c, CMakeLists.txt</files>
  <action>
  **Create directory** `src/layer/` if it doesn't exist.

  **Create `src/layer/tui_layer.c`** with:
  1. Include `cels-ncurses/tui_layer.h` and `<string.h>`
  2. Global state definitions (matching the extern declarations in the header):
     ```c
     TUI_Layer g_layers[TUI_LAYER_MAX];
     int g_layer_count = 0;
     ```
  3. `tui_layer_create(const char* name, int x, int y, int w, int h)`:
     - Return NULL if `g_layer_count >= TUI_LAYER_MAX`
     - Get pointer to `&g_layers[g_layer_count]`
     - `strncpy` name with null termination safety
     - `newwin(h, w, y, x)` -- note ncurses parameter order: lines, cols, begin_y, begin_x
     - Return NULL if newwin fails
     - `new_panel(layer->win)` -- places panel at top of stack
     - If new_panel fails: `delwin(layer->win)`, return NULL
     - `set_panel_userptr(layer->panel, layer)` for reverse lookup
     - Set x, y, width, height, visible=true
     - Increment `g_layer_count`
     - Return the layer pointer

  4. `tui_layer_destroy(TUI_Layer* layer)`:
     - Return early if `!layer` or `!layer->panel`
     - `del_panel(layer->panel)` -- removes from panel stack (does NOT free window)
     - `delwin(layer->win)` -- frees the window
     - Set panel and win to NULL
     - Compact array: compute index as `(int)(layer - g_layers)`, if index < g_layer_count - 1, copy last element to this slot and update the moved element's userptr via `set_panel_userptr(g_layers[idx].panel, &g_layers[idx])`
     - Decrement `g_layer_count`

  **Add source to CMakeLists.txt:**
  In the `target_sources(cels-ncurses INTERFACE ...)` block, add:
  `${CMAKE_CURRENT_SOURCE_DIR}/src/layer/tui_layer.c`

  Follow the existing code style from tui_window.c (section headers, doc comments above functions).
  </action>
  <verify>
  Run: `cd /home/cachy/workspaces/libs/cels && cmake --build build 2>&1 | head -30`
  Build must succeed with no errors. Specifically: no undefined reference to any panel function, no multiple definition errors for g_layers/g_layer_count.
  </verify>
  <done>
  tui_layer.c exists with global state definitions and working create/destroy. Layer create allocates WINDOW + PANEL with userptr. Layer destroy frees PANEL then WINDOW and compacts the array. Build succeeds with panel library linked.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/cachy/workspaces/libs/cels && cmake --build build` compiles without errors
2. `grep -n "PANEL_LIBRARY" modules/cels-ncurses/CMakeLists.txt` shows find_library and target_link_libraries lines
3. `grep -n "new_panel" modules/cels-ncurses/src/layer/tui_layer.c` shows panel creation
4. `grep -n "del_panel" modules/cels-ncurses/src/layer/tui_layer.c` shows panel cleanup before delwin
5. `grep -n "extern" modules/cels-ncurses/include/cels-ncurses/tui_layer.h` shows extern declarations for g_layers and g_layer_count
</verification>

<success_criteria>
- TUI_Layer struct defined with name, panel, win, x, y, width, height, visible fields
- g_layers[TUI_LAYER_MAX] and g_layer_count use extern pattern (declared in .h, defined in .c)
- tui_layer_create allocates newwin + new_panel, sets userptr, returns layer pointer
- tui_layer_destroy calls del_panel THEN delwin (correct order), compacts array, updates moved element's userptr
- CMakeLists.txt finds panelw and links it to both cels-ncurses and draw_test targets
- Full project builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-layer-system/03-01-SUMMARY.md`
</output>
